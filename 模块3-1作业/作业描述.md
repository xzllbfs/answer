一、简答题
1、当我们点击按钮的时候动态给 data 增加的成员是否是响应式数据，如果不是的话，如何把新增成员设置成响应式数据，它的内部原理是什么。

```js
let vm = new Vue({
 el: '#el'
 data: {
  o: 'object',
  dog: {}
 },
 method: {
  clickHandler () {
   // 该 name 属性是否是响应式的
   this.dog.name = 'Trump'
  }
 }
})
```

不是，因为data中的数据都是在创建vue实例的时候，在observer中将属性转换成响应式的数据，如果vue实例创建之后再新增属性，转换响应式数据的过程已经结束。

- 设置初始值

  ```js
  let vm = new Vue({
   el: '#el'
   data: {
    o: 'object',
    dog: {
    	name: ''
  	}
   },
   method: {
    clickHandler () {
     this.dog.name = 'Trump'
    }
   }
  })
  ```

- 使用this.$set

  对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性

  ```js
  let vm = new Vue({
   el: '#el'
   data: {
    o: 'object',
    dog: {
    	name: ''
  	}
   },
   method: {
    clickHandler () {
     this.$set(this.dog, name, 'Trump')
    }
   }
  })
  ```

不是，因为data中的数据都是在创建vue实例的时候，在observer中将属性转换成响应式的数据，如果vue实例创建之后再新增属性，转换响应式数据的过程已经结束。
对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性

2、请简述 Diff 算法的执行过程
diff算法的作用是对比子节点的差异并更新DOM。对比方式是同级别节点依次比较，时间复杂度为O(n)。步骤如下：

第一步：新/旧 开始/结束节点为空：结束节点为空，对应的索引-1；开始节点为空，对应的索引+1

第二步：新/旧 开始/结束节点相同

  - 新**开始**节点 = 旧**开始**节点：对比差异更新DOM，对应的新旧节点索引+1
  - 新**结束**节点 = 旧**结束**节点：对比差异更新DOM，对应的新旧节点索引-1
  - 新结束节点 = 旧开始节点：对比差异更新DOM，将**旧开始**节点移动到**旧结束**节点之后，开始节点索引+1，结束节点索引-1
  - 新开始节点 = 旧结束节点：对比差异更新DOM，将**旧结束**节点移动到**旧开始**节点之前，开始节点索引+1，结束节点索引-1

第三步：新/旧开始/结束节点不同：使用新开始节点的key在旧节点数组中找相同节点

- 有相同节点，将新节点和新增节点队列移动到旧开始节点之前
- 没有相同节点：如果 相同key的旧节点选择器和新节点 不同，创建新的开始节点对应的DOM元素，插入到DOM树中；反之在更新节点之后，将相同key的旧节点对应的DOM元素，移动到新节点之前
- 最后重新给新开始节点赋值，指向下一个新节点

第四步：循环结束后，剩余节点处理：旧节点/新节点数组遍历结束代表循环结束

- 旧节点数组遍历结束 = 新节点有剩余，将新剩余接待追加
- 新节点数组遍历结束 = 旧节点有剩余，批量删除旧剩余节点

二、编程题
1、模拟 VueRouter 的 hash 模式的实现，实现思路和 History 模式类似，把 URL 中的 # 后面的内容作为路由的地址，可以通过 hashchange 事件监听路由地址的变化。

```js
import Vue from 'vue'

let _Vue = null

class VueRouter {
  constructor (options) {
    this.mode = options.mode || 'hash'
    this.options = options
    this.routeMap = {}
    this.app = new Vue({
      data: {
        current: '/'
      }
    })
  }

  static install (Vue) {
    if (VueRouter.install.installed && _Vue === Vue) return
    
    VueRouter.install.installed = true
    _Vue = Vue

    _Vue.mixin({
      beforeCreate () {
        if (this.$option && this.$option.router) {
          _Vue.prototype.$router = this.$option.router
          this.$options.router.init()
        }
      }
    })
  }

  init () {
    this.initRouteMap()
    this.initComponents()
    this.initEvent()
  }

  initRouteMap () {
    // 遍历所有的路由信息
    // routes => [{ name: '', path: '', component: }]
    this.options.routes.forEach(route => {
      // 记录路径和组件的映射
      this.routeMap[route.path] = route.component
    })
  }

  initComponents () {
    const _this = this

    _Vue.component('RouterLink', {
      name: 'RouterLink',
      props: {
        to: String
      },
      render (h) {
        if (_this.options.mode === 'hash') {
          return h('a', {
            attrs: {
              href: `#${this.to}`
            }
          }, [this.$slots.default])
        } else {
          return h('a', {
            attrs: {
              href: this.to
            },
            on: {
              click: this.clickhander
            }
          }, [this.$slots.default])
        }
      },
      methods: {
        clickhander (e) {
          history.pushState({}, '', this.to)
          this.$router.app.current = this.to
          e.preventDefault()
        }
      }
    })

    _Vue.component('RouterView', {
      name: 'RouterView',
      render (h) {
        const cm = _this.routeMap[_this.app.current]
        return h(cm)
      }
    })
  }

  initEvent () {
    if (this.options.mode === 'hash') {
      window.addEventListener('hashchange', this.onHashChange.bind(this))
      window.addEventListener('load', this.onHashChange.bind(this))
    }

    if (this.options.mode === 'history') {
      window.addEventListener('popstate', () => {
        this.app.current = window.location.pathname
      })
    }
  }

  onHashChange () {
    this.app.current = window.location.hash.substr(1) || '/'
  }
}

export default VueRouter
```

2、在模拟 Vue.js 响应式源码的基础上实现 v-html 指令，以及 v-on 指令。

index.html

```html
<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Mini Vue</title>
</head>
<body>
  <div id="app">
    <h1>v-html</h1>
    <div v-html="dom"></div>
    <h1>v-on</h1>
    <div v-on="triggerClick">点击</div>
  </div>
  <script src="./dep.js"></script>
  <script src="./watcher.js"></script>
  <script src="./compiler.js"></script>
  <script src="./observer.js"></script>
  <script src="./vue.js"></script>
  <script>
    let vm = new Vue({
      el: '#app',
      data: {
        msg: 'Hello Vue',
        count: 100,
        person: { name: 'zs' },
        dom: `<span>my html</span>`
      },
      methods: {
        triggerClick () {
          console.log('on-click')
        }
      }
    })
  </script>
</body>
</html>
```

compiler.js

```js
class Compiler {
  constructor (vm) {
    this.el = vm.$el
    this.vm = vm
    // 将methods里的方法注册在Compiler实例上
    this.addHandler(vm.methods)
    this.compile(this.el)
  }
  addHandler (methods) {
    Object.keys(methods).forEach(name => {
      this[name] = methods[name]
    })
  }
  compile (el) {
    let childNodes = el.childNodes
    Array.from(childNodes).forEach(node => {
      if (this.isTextNode(node)) {
        this.compileText(node)
      } else if (this.isElementNode(node)) {
        this.compileElement(node)
      }

      if (node.childNodes && node.childNodes.length) {
        this.compile(node)
      }
    })
  }
  
  compileText (node) {
    let reg = /\{\{(.+?)\}\}/
    let value = node.textContent
    if (reg.test(value)) {
      let key = RegExp.$1.trim()
      node.textContent = value.replace(reg, this.vm[key])

      new Watcher(this.vm, key, (newValue) => {
        node.textContent = newValue
      })
    }
  }

  compileElement (node) {
    Array.from(node.attributes).forEach(attr => {
      let attrName = attr.name
      if (this.isDirective(attrName)) {
        attrName = attrName.substr(2)
        let key = attr.value
        // v-on触发事件
        if (attrName === 'on') {
          this.triggerHandler(node, key)
        } else {
          this.update(node, key, attrName)
        }
      }
    })
  }

  // 触发click事件
  triggerHandler (node, key) {
    node.addEventListener('click', () => {
      this[key]()
    })
  }

  update (node, key, attrName) {
    let updateFn = this[attrName + 'Updater']
    updateFn && updateFn.call(this, node, this.vm[key], key)
  }

  // v-html
  htmlUpdater (node, value, key) {
    node.innerHTML = value
    new Watcher(this.vm, key, (newValue) => {
      node.innerHTML = newValue
    })
  }

  isDirective (attrName) {
    return attrName.startsWith('v-')
  }

  isTextNode (node) {
    return node.nodeType === 3
  }

  isElementNode (node) {
    return node.nodeType === 1
  }
}
```

3、参考 Snabbdom 提供的电影列表的示例，利用Snabbdom 实现类似的效果，如图：

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./src/list.js"></script>
</body>
</html>
```

list.js

```js
import { h, init } from 'snabbdom'
import style from 'snabbdom/modules/style'
import eventlisteners from 'snabbdom/modules/eventlisteners'

let patch = init([
  style,
  eventlisteners
])

const tab = h('ul', [
  h('li', 'Rank'),
  h('li', 'Title'),
  h('li', 'Description')
])

const addBtn = h('button', {
  on: {
    click: addItem
  }
}, 'Add')

const vnode = h('div.container', [
  tab,
  addBtn,
  h('ul.content', [])
])

let app = document.querySelector('#app')
let oldVnode = patch(app, vnode)


let index = 0
function addItem () {
  index ++
  const newNode = h('div.container', [
    tab,
    addBtn,
    h('ul.content', [ h('li', [
      h('span', index + 'Rank'),
      h('button', {
        on: {
          click: delItem
        }
      }, '删除')
    ]) ])
  ])
  patch(oldVnode, newNode)
}

function delItem () {
  alert('删除索引如何传递？')
}
```

